function GoldenRatioOptimizationMethod
% Метод золотого сечения (оптимизационный).
% Установка формата вывода.
format long
% Очистка экрана.
clc
% Очистка переменных.
clear

% Заданная точность вычислений.
e = 0.001;
% Границы отрезка.
a = 0;
b = 8;
% Текущее количество итераций.
iter = 0;
% Максимальное число итераций (страховка).
max_iter_number = 30;    % Значения от 0 и менее не ставить!
% Исходное уравнение.
f = inline('2 * x.^2 - 12 * x');
% Золотое сечение.
F = (1 + sqrt(5)) / 2;

% Вывод графика.
x = a : e : b;
plot(x, f(x));
grid on;

disp ('Метод золотого сечения (метод оптимизации):');
disp (['Отрезок [' num2str(a) ';' num2str(b) ']']);

hasX1AndX2 = true;

% Если при заданных границах отрезка необходимая точность вычислений уже
% достигнута, то цикл не будет выполнен ни разу. В таком случае в качестве
% корня выбираем одну из границ отрезка.
if (abs(a - b) < e)
    x = a;
    
    % Для корректного вывода результатов поднимается флаг,
    % что x1 и x2 не будут вычисляться.
    hasX1AndX2 = false;
end

while ((abs(a - b) >= e) && (iter < max_iter_number))
    iter = iter + 1;

    % Вычисление опорных точек деления.
    x1 = b - (b - a) / F;
    x2 = a + (b - a) / F;

    % Переназначение границ отрезка.
    if (f(x1) >= f(x2))
        a = x1;
    else
        b = x2;
    end
    
    x = (a + b) / 2;
end

% Вывод результатов.
if (hasX1AndX2)
    disp (['x1 = ' num2str(x1)]);
    disp (['x2 = ' num2str(x2)]);
end
disp (['f(x) = ' num2str(f(x))]);
disp (['x = ' num2str(x)]);
disp (['Заданная точность вычислений: ' num2str(e)]);
disp (['Количество итераций: ' num2str(iter)]);